/*<!--

 BSD 3-Clause License

  Copyright (c) 2020 Okinawa Institute of Science and Technology (OIST).
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials provided
     with the distribution.
   * Neither the name of Willow Garage, Inc. nor the names of its
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

 Author: Hendry F. Chame <hendryfchame@gmail.com>

 Publication:

   Chame, H. F., Ahmadi, A., & Tani, J. (2020).
   A hybrid human-neurorobotics approach to primary intersubjectivity via
   active inference. Frontiers in psychology, 11.

   Okinawa Institute of Science and Technology Graduate University (OIST)
   Cognitive Neurorobotics Research Unit (CNRU)
   1919-1, Tancha, Onna, Kunigami District, Okinawa 904-0495, Japan

-->*/

#include "../includes.h"
#include "../lib/LibNRL.h"
#include "../utils/Utils.h"
#include "CircularBuffer.h"
#include <thread>

using namespace std;
using namespace oist;

/**
 * Demonstration on how to train a model
 * @param nrl Pointer to the NRL singleton instance
 * */
void demonstrateTraining(LibNRL* nrl) {

	cout << endl << "training demonstration begin" << endl << endl;

	nrl->t_background();

	cout << endl << "training demonstration end" << endl << endl;

}

/**
 * Demonstration of real-time experiment
 * @param nrl Pointer to the NRL singleton instance
 * */
void demonstrateExperiment(LibNRL* nrl) {

	cout << endl << "simulation demonstration begin" << endl << endl;

	nrl->load();


	int nDof = nrl->getNDof();

	if (nDof > 0) {

		int winSize = 15;
		int winBufferSize = winSize * nDof;
		CircularBuffer winBufferData(winSize, nDof);
		int primId = 0;

		float* model_state = new float[nrl->getStateDim()];
		for (int i = 0 ; i < nrl->getStateDim(); i++)
			model_state[i] = 0.0;

		// The e_w parameters set bellow assume the network has two layers
		// as in the original distribution of the sources
		// in case more layers are set by changing the properties.d file,
		// the same dimension for e_w must be considered
		float e_w[2] = { 0.025, 0.025 };

		int expTimeSteps = 15;
		int postdiction_epochs = 15;
		float alpha = 0.1;
		float beta1 = 0.9;
		float beta2 = 0.999;
		bool storeStates = false;
		bool storeER = false;
		bool showERLog = false;
		nrl->e_enable(primId, winSize, e_w, expTimeSteps, postdiction_epochs,
				alpha, beta1, beta2, storeStates, storeER);
		float* tgt_pos = new float[nDof];
		float* cur_pos = new float[nDof];


		// information on free energy minimization		
		float elboOut[3] = { 0.0, 0.0, 0.0 };

		for (int i = 0; i < nDof; i++) {
			tgt_pos[i] = 0.0;
			cur_pos[i] = 0.0;
		}

		int t = 0;

		bool endExperiment = false;

		while (!endExperiment) {

			// get time in ms
			 chrono::high_resolution_clock::time_point mst1 = chrono::high_resolution_clock::now();

			// < --- Here you should read the robot's joint state
			// Since this is a dummy example, the current posture
			// 'cur_pos' is set to zero
			for (int i = 0; i < nDof; i++) {
				cur_pos[i] = 0.0;
			}

			// The target posture is generated by the RNN
			nrl->e_generate(tgt_pos);

			// < --- Here you should call asynchronously the robot driver 
			// and send it tgt_pos to move the robot

			// store the current posture in the buffer
			winBufferData.push(cur_pos);

			if (winBufferData.size() == winSize) {
				t += 1;

				// call to postdiction (inference) process
				// Optional: Information on free energy minimization (elboOut)
				// can be obtained and analyzed on-line
				nrl->e_postdict(winBufferData.getData(), elboOut, showERLog);

				// Optional: The latent state of the network can be obtained
				// analyzed on-line or stored for future analysis
				nrl->e_getState(model_state);

			}

			// get time in ms
			chrono::high_resolution_clock::time_point mst2 = chrono::high_resolution_clock::now();
			float detla_t = chrono::duration_cast<chrono::milliseconds>(mst2 - mst1).count();
			mst1 = mst2;
			if (t > 0) {
				std::cout << "Step: " << t << " in " << detla_t << " ms" << std::endl;
			}

			// For real applications you should set the program to sleep according to the
			// desired loop period

			float period = 0.0; // loop period in ms
			float sleepTime = period - detla_t;
			if (sleepTime > 1.0)
				std::this_thread::sleep_for(std::chrono::milliseconds((int) sleepTime));

			if (t == expTimeSteps)
				endExperiment = true;

		}
		// deallocating buffers 
		delete[] tgt_pos;
		delete[] cur_pos;
		delete[] model_state;
	} else {
		cout << endl << "Hint: the model path may be incorrect, or perhaps it requires to be trained !"	<< endl;
	}

	cout << endl << "simulation demonstration end" << endl << endl;
}

int main(int argc, char** argv) {

	cout << endl;
	cout << "-----------------------------" << endl;
	cout << "Neural Robotics Libray (NRL)" << endl;
	cout << "-----------------------------" << endl << endl;
	cout << "This is a demonstration program for stand alone application " << endl << endl;
	cout << "**** Instructions **** " << endl << endl;
	cout << "To run: NRL_SA [PATH] [train|sim]" << endl << endl;
	cout << "Arguments" << endl << endl;

	cout << "PATH:  Full path to the property file distributed in 'src/standalone/data/config/properties.d'" << endl << endl;

	cout << "train: trains a model for a generic 16 degrees of freedom robot with dumb data" << endl;
	cout << "       the parameters can be selected by editing the file 'properties.d'" << endl << endl;
	cout << "sim:   simulates on-line interaction with the robot during 50 time steps" << endl;
	cout << "       the loop time in milliseconds is shown in the standard output" << endl << endl;
	cout << "******************** " << endl;

	LibNRL* nrl = LibNRL::getInstance();
	Utils* ut = Utils::getInstance();

	// verifying the arguments

	string path;

	if (argc > 1) {
		for (int i = 1; i < argc; ++i) {
			string arg_s = string(argv[i]);
			if (i == 1) {
				path = arg_s;
				cout << endl << "Loading the properties file from: [" << path << "]" << endl << endl;
				nrl->newModel(path);
				continue;
			}
			ut->tolower(arg_s);
			if (arg_s == "train")
				demonstrateTraining(nrl);
			else if (arg_s == "sim")
				demonstrateExperiment(nrl);
			else
				cout << "Please indicate a valid argument [train,sim] !" << endl;
		}

	}

	cout << "Program end" << endl << endl;

}
